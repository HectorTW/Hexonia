<!DOCTYPE html>
<html>
<head>
    <title>Совместное рисование по локальной сети</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; }
        canvas { 
            border: 2px solid #000; 
            margin-top: 10px;
            background-color: #f0f0f0;
        }
        .controls { margin: 10px; }
        input, button { padding: 8px; margin: 5px; }
    </style>
</head>
<body>
    <h1>Совместное рисование (как в Minecraft)</h1>
    
    <div class="controls">
        <button id="hostBtn">Создать комнату</button>
        <button id="joinBtn">Присоединиться</button>
        <input id="peerIdInput" placeholder="Введите ID комнаты">
        <button id="clearBtn">Очистить холст</button>
        <div>
            Цвет: <input type="color" id="colorPicker" value="#000000">
            Толщина: <input type="range" id="lineWidth" min="1" max="20" value="5">
        </div>
    </div>

    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <script>
        // Настройка PeerJS
        const peer = new Peer();
        let conn = null;
        let isHost = false;

        // Настройка холста
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // Настройки рисования
        const colorPicker = document.getElementById('colorPicker');
        const lineWidth = document.getElementById('lineWidth');
        let currentColor = '#000000';
        let currentWidth = 5;

        colorPicker.addEventListener('change', (e) => currentColor = e.target.value);
        lineWidth.addEventListener('change', (e) => currentWidth = e.target.value);

        // Очистка холста
        document.getElementById('clearBtn').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (conn) conn.send({ type: 'clear' });
        });

        // Создание комнаты
        document.getElementById('hostBtn').addEventListener('click', () => {
            isHost = true;
            alert(`Ваш ID комнаты: ${peer.id}. Другой игрок должен ввести его для подключения.`);
        });

        // Подключение к комнате
        document.getElementById('joinBtn').addEventListener('click', () => {
            const hostId = document.getElementById('peerIdInput').value;
            if (!hostId) return alert("Введите ID комнаты!");

            conn = peer.connect(hostId);
            
            conn.on('open', () => {
                alert(`Вы подключились к комнате ${hostId}!`);
            });

            conn.on('data', handleIncomingData);
        });

        // Обработка входящих подключений
        peer.on('connection', (connection) => {
            conn = connection;
            conn.on('data', handleIncomingData);
        });

        // Обработка данных от другого игрока
        function handleIncomingData(data) {
            if (data.type === 'draw') {
                drawLine(data.x1, data.y1, data.x2, data.y2, data.color, data.width);
            } else if (data.type === 'clear') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Рисование линии
        function drawLine(x1, y1, x2, y2, color, width) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.stroke();
        }

        // Обработка событий мыши/касания
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            startDrawing(mouseEvent);
        });

        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = {
                clientX: touch.clientX,
                clientY: touch.clientY
            };
            draw(mouseEvent);
        });

        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchend', stopDrawing);

        function startDrawing(e) {
            isDrawing = true;
            [lastX, lastY] = [e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop];
        }

        function draw(e) {
            if (!isDrawing) return;
            const x = e.clientX - canvas.offsetLeft;
            const y = e.clientY - canvas.offsetTop;

            // Рисуем локально
            drawLine(lastX, lastY, x, y, currentColor, currentWidth);

            // Отправляем данные другому игроку
            if (conn && conn.open) {
                conn.send({
                    type: 'draw',
                    x1: lastX, y1: lastY,
                    x2: x, y2: y,
                    color: currentColor,
                    width: currentWidth
                });
            }

            [lastX, lastY] = [x, y];
        }

        function stopDrawing() {
            isDrawing = false;
        }
    </script>
</body>
</html>